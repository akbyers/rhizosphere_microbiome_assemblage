---
title: "Data analysis: Nature vs Nurture in the rhizosphere"
author: "Alexa Byers"
date: "21/04/2022 (last edited)"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
#load libraries
```{r}
library(vegan)
library(dendextend)
library(picante)
library(stats)
library(pairwiseAdonis)
library(ggConvexHull)
library(ecodist)
library(phyloseq)
library(ggplot2)
library(scales)
library(dplyr)
library(stats)
library(microbiome)
library(tidyverse)
library(heatmaply)
library(metagenomeSeq)
library(ape)
library(ggpubr)
library(betapart)
library(psych)
theme_set(theme_bw())
```
## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.
When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

#1. Set up phyloseq objects using outputs of dada2 processing (files were cleaned post dada2 to remove singletons, unidentified phyla, and Chloroplasts/Cyanobacteria)

#load ITS data
```{r load ITS ASV data files and create phyloseq object}
ASV.ITS <- read.csv("~/Xioben data/Alexa_TRM_analysis/ITS sequencing/ASV_counts_cleaned.csv")
Taxa.ITS <- read.csv("~/Xioben data/Alexa_TRM_analysis/ITS sequencing/Taxonomy_cleaned.csv")
Sample.ITS <- read.csv("~/Xioben data/Alexa_TRM_analysis/ITS sequencing/ITS_samples_post_filtering.csv")
ITS.tree <- read.tree("~/Xioben data/Alexa_TRM_analysis/Phylotree construction/ITS_fasttreeRooted/tree.nwk")
row.names(ASV.ITS) = ASV.ITS$ASVs
ASV.ITS = ASV.ITS[,-1:-2]
row.names(Taxa.ITS) = Taxa.ITS$ASVs
Taxa.ITS = Taxa.ITS[-1:-2]
row.names(Sample.ITS) = Sample.ITS$SampleID
```
# create phyloseq object
```{r}
ASVS.ITS = otu_table(as.matrix(ASV.ITS), taxa_are_rows = TRUE)
TAXA.ITS = tax_table(as.matrix(Taxa.ITS))
SAMPLES.ITS = sample_data(Sample.ITS)
ITS.tree = phy_tree(ITS.tree)
physeq_ITS = phyloseq(ASVS.ITS, TAXA.ITS, SAMPLES.ITS, ITS.tree)
physeq_ITS ##we have 6010 taxa present across 216 samples
```
#load 16S data
```{r read in and prepare 16S data}
ASV.16S <- read.csv("~/Xioben data/Alexa_TRM_analysis/16S data/DADA2 outputs/DADA2 outputs/ASV_counts_cleaned.csv")
Taxa.16S <- read.csv("~/Xioben data/Alexa_TRM_analysis/16S data/DADA2 outputs/DADA2 outputs/Taxonomy_cleaned.csv")
Sample.16S <- read.csv("~/Xioben data/Alexa_TRM_analysis/16S data/DADA2 outputs/16S_samples_post_filtering.csv")
x16S.tree <- read.tree("~/Xioben data/Alexa_TRM_analysis/Phylotree construction/16s_fasttreeRooted/tree.nwk")
ASV.16S = ASV.16S[,-1]
row.names(ASV.16S) = ASV.16S$ASV_ID
ASV.16S = ASV.16S[,-1]
row.names(Taxa.16S) = Taxa.16S$ASV_ID
Taxa.16S = Taxa.16S[-1:-2]
row.names(Sample.16S) = Sample.16S$SampleID
```
#create 16S phyloseq object
```{r}
ASVS.16S = otu_table(as.matrix(ASV.16S), taxa_are_rows = TRUE)
TAXA.16S = tax_table(as.matrix(Taxa.16S))
SAMPLES.16S = sample_data(Sample.16S)
x16S.tree = phy_tree(x16S.tree)
physeq.16S = phyloseq(ASVS.16S, TAXA.16S, SAMPLES.16S, x16S.tree)
physeq.16S ##we have 12518 taxa present across 207 samples
```

#rarefy phyloseq objects to even ASV counts
#ITS
```{r}
ITS_sample_sums <- sample_sums(physeq_ITS) #calculate sample sums

##remove samples with low read counts (less than 9000)
Samples_toRemove_ITS <- c("kabir_ITS2rcbc567", "kabir_ITS2rcbc556", "kabir_ITS2rcbc459", "kabir_ITS2rcbc403", "kabir_ITS2rcbc555", "kabir_ITS2rcbc464")
physeq2_ITS <- subset_samples(physeq_ITS, !(SampleID %in% Samples_toRemove_ITS))
#remove ITS samples with no plant data
physeq3_ITS <- subset_samples(physeq2_ITS, PlantID !="NPD")
#remove ITS taxa which may now have 0 counts
physeq4_ITS <- prune_taxa(taxa_sums(physeq3_ITS) > 1 , physeq3_ITS)
any(taxa_sums(physeq4_ITS)== 0)

#rarefy ITS data to minimum sampling depth (5712 ASV counts)
physeq.rarefied_ITS = rarefy_even_depth(physeq4_ITS, rngseed=1, sample.size=1*min(sample_sums(physeq4_ITS)), replace=F) 
```
#ALPHA DIVERSITY
#ITS
```{r}
asv_its <- as.data.frame(otu_table(physeq.rarefied_ITS))
tree_its <- phy_tree(physeq.rarefied_ITS)
pd.diversity_ITS <- pd(t(asv_its), tree_its, include.root = TRUE) #calculate phylogenetic diversity
pd.diversity_ITS <- cbind(pd.diversity_ITS, sample_data(physeq.rarefied_ITS))
#write.csv(pd.diversity_ITS, "~/Documents/Alexa_TRM_analysis/January 2022/ITS_alpha_diversity.csv")
```
```{r}
#summarise alpha diversity results for each plant metadata factor
#phylogenetic diversity
pd.diversity_ITS1 <- describe.by(pd.diversity_ITS$PD, pd.diversity_ITS$PlantID, mat = TRUE, digits=3)
pd.diversity_ITS2 <- describe.by(pd.diversity_ITS$PD, pd.diversity_ITS$Genus, mat = TRUE, digits=3)
pd.diversity_ITS3 <- describe.by(pd.diversity_ITS$PD, pd.diversity_ITS$Family, mat = TRUE, digits=3)
pd.diversity_ITS4 <- describe.by(pd.diversity_ITS$PD, pd.diversity_ITS$Order, mat = TRUE, digits=3)
pd.diversity_ITS5 <- describe.by(pd.diversity_ITS$PD, pd.diversity_ITS$Class, mat = TRUE, digits=3)
pd.diversity_ITS6 <- describe.by(pd.diversity_ITS$PD, pd.diversity_ITS$Life.span, mat = TRUE, digits=3)
pd.diversity_ITS7 <- describe.by(pd.diversity_ITS$PD, pd.diversity_ITS$Nitrogen.fixing, mat = TRUE, digits=3)
pd.diversity_ITS8 <- describe.by(pd.diversity_ITS$PD, pd.diversity_ITS$Primary.mycorrhizal.association, mat = TRUE, digits=3)
pd.diversity_ITS9 <- describe.by(pd.diversity_ITS$PD, pd.diversity_ITS$Provenance, mat = TRUE, digits=3)
pd.diversity_ITS10 <- describe.by(pd.diversity_ITS$PD, pd.diversity_ITS$Functional.group, mat = TRUE, digits=3)

#create single summary table
pd_diversity_summary <- rbind(pd.diversity_ITS1, pd.diversity_ITS2, pd.diversity_ITS3, pd.diversity_ITS4, pd.diversity_ITS5, pd.diversity_ITS6, pd.diversity_ITS7, pd.diversity_ITS8, pd.diversity_ITS9, pd.diversity_ITS10)
write.csv(pd_diversity_summary, "~/Documents/Alexa_TRM_analysis/January 2022/pd_diversity_summary.csv")

#species richness
SR.diversity_ITS1 <- describe.by(pd.diversity_ITS$SR, pd.diversity_ITS$PlantID, mat = TRUE, digits=3)
SR.diversity_ITS2 <- describe.by(pd.diversity_ITS$SR, pd.diversity_ITS$Genus, mat = TRUE, digits=3)
SR.diversity_ITS3 <- describe.by(pd.diversity_ITS$SR, pd.diversity_ITS$Family, mat = TRUE, digits=3)
SR.diversity_ITS4 <- describe.by(pd.diversity_ITS$SR, pd.diversity_ITS$Order, mat = TRUE, digits=3)
SR.diversity_ITS5 <- describe.by(pd.diversity_ITS$SR, pd.diversity_ITS$Class, mat = TRUE, digits=3)
SR.diversity_ITS6 <- describe.by(pd.diversity_ITS$SR, pd.diversity_ITS$Life.span, mat = TRUE, digits=3)
SR.diversity_ITS7 <- describe.by(pd.diversity_ITS$SR, pd.diversity_ITS$Nitrogen.fixing, mat = TRUE, digits=3)
SR.diversity_ITS8 <- describe.by(pd.diversity_ITS$SR, pd.diversity_ITS$Primary.mycorrhizal.association, mat = TRUE, digits=3)
SR.diversity_ITS9 <- describe.by(pd.diversity_ITS$SR, pd.diversity_ITS$Provenance, mat = TRUE, digits=3)
SR.diversity_ITS10 <- describe.by(pd.diversity_ITS$SR, pd.diversity_ITS$Functional.group, mat = TRUE, digits=3)

#create single summary table
SR_diversity_summary <- rbind(SR.diversity_ITS1, SR.diversity_ITS2, SR.diversity_ITS3, SR.diversity_ITS4, SR.diversity_ITS5, SR.diversity_ITS6, SR.diversity_ITS7, SR.diversity_ITS8, SR.diversity_ITS9, SR.diversity_ITS10)
write.csv(SR_diversity_summary, "~/Documents/Alexa_TRM_analysis/January 2022/SR_diversity_summary_ITS.csv")
```
#rarefy 16S ASV table
```{r}
sample_sums_16S <- sample_sums(physeq.16S) #calculate sample sums

#remove 16S samples with low read counts below 5000
Samples_toRemove_16S <- c("X128", "X530", "X183", "X646", "X740", "X117", "X642", "X580", "X23", "X513", "X625", "X156", "X669", "X626", "X714", "X586", "X87", "X641", "X226", "X549", "X120", "X453")
physeq2.16S <- subset_samples(physeq.16S, !(SampleID %in% Samples_toRemove_16S))
#remove 16S samples with no plant data
physeq3.16S <- subset_samples(physeq2.16S, PlantID !="NPD")
#remove 16S taxa which may now have < 1 count
physeq4.16S <- prune_taxa(taxa_sums(physeq3.16S) > 1 , physeq3.16S)
any(taxa_sums(physeq4.16S)== 0)

#rarefy 16S table to minimum sampling depth (5509 ASV counts)
physeq.rarefied.16S = rarefy_even_depth(physeq4.16S, rngseed=1, sample.size=1*min(sample_sums(physeq4.16S)), replace=F)
sample_sums(physeq.rarefied.16S) 
```

#alpha diversity on rarefied 16S data
```{r}
#calculate phylogenetic diversity
asv_16s <- as.data.frame(otu_table(physeq.rarefied.16S))
tree_16s <- phy_tree(physeq.rarefied.16S)
pd.diversity_16S <- pd(t(asv_16s), tree_16s, include.root = TRUE)
pd.diversity_16S <- cbind(pd.diversity_16S, sample_data(physeq.rarefied.16S))
#write.csv(pd.diversity_16S, "~/Documents/Alexa_TRM_analysis/January 2022/16S_alpha_diversity.csv")
```
```{r}
#summarise alpha diversity results for each plant metadata factor
#phylogenetic diversity
pd.diversity_16S1 <- describe.by(pd.diversity_16S$PD, pd.diversity_16S$PlantID, mat = TRUE, digits=3)
pd.diversity_16S2 <- describe.by(pd.diversity_16S$PD, pd.diversity_16S$Genus, mat = TRUE, digits=3)
pd.diversity_16S3 <- describe.by(pd.diversity_16S$PD, pd.diversity_16S$Family, mat = TRUE, digits=3)
pd.diversity_16S4 <- describe.by(pd.diversity_16S$PD, pd.diversity_16S$Order, mat = TRUE, digits=3)
pd.diversity_16S5 <- describe.by(pd.diversity_16S$PD, pd.diversity_16S$Class, mat = TRUE, digits=3)
pd.diversity_16S6 <- describe.by(pd.diversity_16S$PD, pd.diversity_16S$Life.span, mat = TRUE, digits=3)
pd.diversity_16S7 <- describe.by(pd.diversity_16S$PD, pd.diversity_16S$Nitrogen.fixing, mat = TRUE, digits=3)
pd.diversity_16S8 <- describe.by(pd.diversity_16S$PD, pd.diversity_16S$Primary.mycorrhizal.association, mat = TRUE, digits=3)
pd.diversity_16S9 <- describe.by(pd.diversity_16S$PD, pd.diversity_16S$Provenance, mat = TRUE, digits=3)
pd.diversity_16S10 <- describe.by(pd.diversity_16S$PD, pd.diversity_16S$Functional.group, mat = TRUE, digits=3)

#create single summary table
pd_diversity_summary2 <- rbind(pd.diversity_16S1, pd.diversity_16S2, pd.diversity_16S3, pd.diversity_16S4, pd.diversity_16S5, pd.diversity_16S6, pd.diversity_16S7, pd.diversity_16S8, pd.diversity_16S9, pd.diversity_16S10)
write.csv(pd_diversity_summary2, "~/Documents/Alexa_TRM_analysis/January 2022/pd_diversity_summary_16S.csv")

#species richness
SR.diversity_16S1 <- describe.by(pd.diversity_16S$SR, pd.diversity_16S$PlantID, mat = TRUE, digits=3)
SR.diversity_16S2 <- describe.by(pd.diversity_16S$SR, pd.diversity_16S$Genus, mat = TRUE, digits=3)
SR.diversity_16S3 <- describe.by(pd.diversity_16S$SR, pd.diversity_16S$Family, mat = TRUE, digits=3)
SR.diversity_16S4 <- describe.by(pd.diversity_16S$SR, pd.diversity_16S$Order, mat = TRUE, digits=3)
SR.diversity_16S5 <- describe.by(pd.diversity_16S$SR, pd.diversity_16S$Class, mat = TRUE, digits=3)
SR.diversity_16S6 <- describe.by(pd.diversity_16S$SR, pd.diversity_16S$Life.span, mat = TRUE, digits=3)
SR.diversity_16S7 <- describe.by(pd.diversity_16S$SR, pd.diversity_16S$Nitrogen.fixing, mat = TRUE, digits=3)
SR.diversity_16S8 <- describe.by(pd.diversity_16S$SR, pd.diversity_16S$Primary.mycorrhizal.association, mat = TRUE, digits=3)
SR.diversity_16S9 <- describe.by(pd.diversity_16S$SR, pd.diversity_16S$Provenance, mat = TRUE, digits=3)
SR.diversity_16S10 <- describe.by(pd.diversity_16S$SR, pd.diversity_16S$Functional.group, mat = TRUE, digits=3)
#create single summary table
SR_diversity_summary2 <- rbind(SR.diversity_16S1, SR.diversity_16S2, SR.diversity_16S3, SR.diversity_16S4, SR.diversity_16S5, SR.diversity_16S6, SR.diversity_16S7, SR.diversity_16S8, SR.diversity_16S9, SR.diversity_16S10)
write.csv(SR_diversity_summary2, "~/Documents/Alexa_TRM_analysis/January 2022/SR_diversity_summary_16S.csv")
```
#kruskal wallis tests on 16S alpha diversity
```{r}
KW_16S_data <- data.frame(pd.diversity_16S[c(5:14)])
KW_16S_SR <- lapply(KW_16S_data, function(x) kruskal.test(pd.diversity_16S$SR ~ x))
KW_16S_PD <- lapply(KW_16S_data, function(x) kruskal.test(pd.diversity_16S$PD ~ x))
#pairwise wilcox
PW_16S_SR <- lapply(KW_16S_data, function(x) pairwise.wilcox.test(pd.diversity_16S$SR, x, p.adjust.method = "bonferroni"))
PW_16S_PD <- lapply(KW_16S_data, function(x) pairwise.wilcox.test(pd.diversity_16S$PD, x, p.adjust.method = "bonferroni"))
```



###BETA DIVERSITY ANALYSIS

###ITS beta diversity analysis
#using non pime filtered phyloseq object

#ITS community compositon using weighted UniFrac
```{r}
physeq.rarefied_ITS <- subset_samples(physeq.rarefied_ITS, SampleID !="kabir_ITS2rcbc295") #huge outliers
physeq.rarefied_ITS <- subset_samples(physeq.rarefied_ITS, SampleID !="kabir_ITS2rcbc532") 
unifrac.its <- phyloseq::distance(physeq.rarefied_ITS, "wunifrac")
ordination.its <- ordinate(physeq.rarefied_ITS, method = "NMDS", distance= unifrac.its)
sample.its <- data.frame(sample_data(physeq.rarefied_ITS))
#write.csv(sample.its, "~/Documents/Alexa_TRM_analysis/January 2022/CoreSamples_ITS.csv")
```
#adonis and pairwise adonis testing
```{r}
Adonis_ITS_data <- sample.its[c(3:12)]
Adonis_unifrac_ITS <- lapply(Adonis_ITS_data, function(x) vegan::adonis(unifrac.its ~ x))
Adonis.ITS.Results <- data.frame(R.Sq = sapply(Adonis_unifrac_ITS, function(x) x$aov.tab$R2),
           p.value = sapply(Adonis_unifrac_ITS, function(x) x$aov.tab$`Pr(>F)`))
write.csv(Adonis.ITS.Results, "~/Xioben data/Alexa_TRM_analysis/January 2022/Adonis_ITS.csv")
#devtools::install_github("pmartinezarbizu/pairwiseAdonis/pairwiseAdonis")
library(pairwiseAdonis)
Pairwise_adonis_ITS <- lapply(Adonis_ITS_data, function(x) pairwise.adonis(unifrac.its, x, p.adjust.m = "bonferroni", reduce = NULL, perm = 999))

##filter to only retain sig pairwise differences
install.packages("rlist")
library(rlist)
Pairwise_adonis_ITS2 <- lapply(Pairwise_adonis_ITS, function(x) dplyr::filter(x, p.adjusted < 0.05))
##need to filter this
#capture.output(Pairwise_adonis_ITS2, file = "~/Documents/Alexa_TRM_analysis/January 2022/pairwiseAdonis_ITS.csv")
```
#NMDS plots. Setting consistent layout style
```{r its nmds plots}
nmds_layout = 
    theme_bw() + 
    theme(axis.text.y = element_text(colour = "black", size = 12, face = "bold"), 
    axis.text.x = element_text(colour = "black", face = "bold", size = 12), 
    legend.text = element_text(size = 12, face ="bold", colour ="black"), 
    legend.position = "right", axis.title.y = element_text(face = "bold", size = 14), 
    axis.title.x = element_text(face = "bold", size = 14, colour = "black"), 
    legend.title = element_text(size = 14, colour = "black", face = "bold"), 
    panel.background = element_blank(), panel.border = element_rect(colour = "black", fill = NA, size = 1.2),
    legend.key=element_blank())
```
```{r}
its_plot = plot_ordination(physeq.rarefied_ITS, ordination.its, type="samples", color="PlantID") +
    nmds_layout + 
    geom_point(size=4, alpha= 1)+
    geom_convexhull(aes(fill= PlantID), alpha=.6)
png("~/Xioben data/Alexa_TRM_analysis/January 2022/ITS_NMDS.png", width = 800, height = 600)
its_plot
```

#mantel tests to correlate env variables. How do env variables impact core taxa?
##soil chemical variables don't correlate to unifrac distances
```{r its mantel tests; data prep}
sample.ITS2 <- data.frame(sapply(sample.its[,14:24], as.numeric))
rownames(sample.ITS2) <- rownames(sample.its)
its.vegdist <- lapply(sample.ITS2, vegdist, method="euclidean", na.rm = TRUE)

#mantel tests on weighted unifrac distances
Mantel.ITS <- lapply(its.vegdist, function(x) vegan::mantel(x, unifrac.its, method="spearman", permutations = 999, na.rm = TRUE))
Mantel.ITS.Results <- data.frame(Mantel.r = sapply(Mantel.ITS, function(x) x$statistic), p.value = sapply(Mantel.ITS, function(x) x$signif))
write.csv(Mantel.ITS.Results, "~/Xioben data/Alexa_TRM_analysis/January 2022/Mantel_ITS.csv")
```

##betadisper tests to analyse within group variance
```{r}
Betadisp_ITS_data <- sample.its[c(3:12)]
betadisp_its <- lapply(Betadisp_ITS_data, function(x) vegan::betadisper(unifrac.its, x, type = "median", bias.adjust = FALSE)) #calculating betadispersion

#exporting betadisp distances
betadisp_distances_ITS <- data.frame(sapply(betadisp_its, function(x) x$distances), sapply(betadisp_its, function(x) x$group))
write.csv(betadisp_distances_ITS, "~/Xioben data/Alexa_TRM_analysis/January 2022/betadispDistances_ITS.csv")

permu_betadisp_its <- lapply(betadisp_its, permutest, pairwise=TRUE) #permutation tests
#exporting results
permu_betadisp_its.Results <- data.frame(F_value = sapply(permu_betadisp_its, function(x) x$tab$`F`),
           p.value = sapply(permu_betadisp_its, function(x) x$tab$`Pr(>F)`))
write.csv(permu_betadisp_its.Results, "~/Xioben data/Alexa_TRM_analysis/January 2022/Perm_Betadisp_its.csv")

#pairwise tests on betadispersion
Permu_betadisp_its.pairwise <- lapply(permu_betadisp_its, function (x) x$pairwise$permuted <- x$pairwise$permuted[!(x$pairwise$permuted > 0.05)]) #only keeping sig results for output
capture.output(Permu_betadisp_its.pairwise, file = "~/Xioben data/Alexa_TRM_analysis/January 2022/Permu_Pairwise_Betadisp_its.csv")
```

##betadispersion summary statistics
```{r}
BD_ITS.PlantID <- describe.by(betadisp_unifrac_distances_ITS$PlantID, betadisp_unifrac_distances_ITS$PlantID.1, mat = TRUE, digits=3)
BD_ITS.Genus <- describe.by(betadisp_unifrac_distances_ITS$Genus, betadisp_unifrac_distances_ITS$Genus.1, mat = TRUE, digits=3)
BD_ITS.Family <- describe.by(betadisp_unifrac_distances_ITS$Family, betadisp_unifrac_distances_ITS$Family.1, mat = TRUE, digits=3)
BD_ITS.Order <- describe.by(betadisp_unifrac_distances_ITS$Order, betadisp_unifrac_distances_ITS$Order.1, mat = TRUE, digits=3)
BD_ITS.Class <- describe.by(betadisp_unifrac_distances_ITS$Class, betadisp_unifrac_distances_ITS$Class.1, mat = TRUE, digits=3)
BD_ITS.Provenance <- describe.by(betadisp_unifrac_distances_ITS$Provenance, betadisp_unifrac_distances_ITS$Provenance.1, mat = TRUE, digits=3)
BD_ITS.PMA <- describe.by(betadisp_unifrac_distances_ITS$Primary.mycorrhizal.association, betadisp_unifrac_distances_ITS$Primary.mycorrhizal.association.1, mat = TRUE, digits=3)
BD_ITS.NF <- describe.by(betadisp_unifrac_distances_ITS$Nitrogen.fixing, betadisp_unifrac_distances_ITS$Nitrogen.fixing.1, mat = TRUE, digits=3)
BD_ITS.FG <- describe.by(betadisp_unifrac_distances_ITS$Functional.group, betadisp_unifrac_distances_ITS$Functional.group.1, mat = TRUE, digits=3)
BD_ITS.LS <- describe.by(betadisp_unifrac_distances_ITS$Life.span, betadisp_unifrac_distances_ITS$Life.span.1, mat = TRUE, digits=3)

#capture into one summary table
Betadispersion_its_summary <- rbind(BD_ITS.PlantID, BD_ITS.Genus, BD_ITS.Family, BD_ITS.Order, BD_ITS.Class, BD_ITS.Provenance, BD_ITS.PMA, BD_ITS.NF, BD_ITS.FG, BD_ITS.LS)
write.csv(Betadispersion_its_summary, "~/Documents/Alexa_TRM_analysis/January 2022/Betadispersion_summary_ITS.csv")
```

##16S beta diversity analysis
#calculating weighted UniFrac matrices
```{r}
unifrac.16S <- phyloseq::distance(physeq.rarefied.16S, "wunifrac")
ordination.16S <- ordinate(physeq.rarefied.16S, method = "NMDS", distance= unifrac.16S) #nmds ordination
sample.16S <- data.frame(sample_data(physeq.rarefied.16S))
#write.csv(sample.16S, "~/Documents/Alexa_TRM_analysis/January 2022/CoreSamples_16S.csv")
```
#adonis and pairwise adonis testing
```{r}
Adonis_16S_data <- sample.16S[c(3:12)]
Adonis_tests_16S <- lapply(Adonis_16S_data, function(x) vegan::adonis(unifrac.16S ~ x))
Adonis.16S.Results <- data.frame(R.Sq = sapply(Adonis_tests_16S, function(x) x$aov.tab$R2),
           p.value = sapply(Adonis_tests_16S, function(x) x$aov.tab$`Pr(>F)`))
write.csv(Adonis.16S.Results, "~/Xioben data/Alexa_TRM_analysis/January 2022/Adonis_16S.csv")

#pairwise adonis
Pairwise_adonis_16S <- lapply(Adonis_16S_data, function(x) pairwise.adonis(unifrac.16S, x, p.adjust.m = "bonferroni", reduce = NULL, perm = 999))
Pairwise_adonis_16S2 <- lapply(Pairwise_adonis_16S, function(x) dplyr::filter(x, p.adjusted < 0.05))
capture.output(Pairwise_adonis_16S2, "~/Xioben data/Alexa_TRM_analysis/January 2022/pairwise_Adonis_16S.csv")
```
##16S nmds plots
```{r}
x16S_plot = plot_ordination(physeq.rarefied.16S, ordination.16S, type="samples", color="PlantID") +   nmds_layout + 
    geom_point(size=4, alpha= 1)+
    geom_convexhull(aes(fill= PlantID), alpha=.6)
png("~/Xioben data/Alexa_TRM_analysis/January 2022/16S_NMDS.png", width = 800, height = 600)
x16S_plot
```
#mantel tests to correlate env variables. 
```{r 16S mantel tests; data prep}
sample.16S2 <- data.frame(sapply(sample.16S[,14:24],as.numeric))
rownames(sample.16S2) = rownames(sample.16S2)
x16s.vegdist <- lapply(sample.16S2, vegdist, method="euclidean", na.rm = TRUE)
Mantel.16S <- lapply(x16s.vegdist, function(x) vegan::mantel(x, unifrac.16S, method="spearman", permutations = 999, na.rm = TRUE))

#exporting results
Mantel.16S.Results <- data.frame(Mantel.r = sapply(Mantel.16S, function(x) x$statistic),
           p.value = sapply(Mantel.16S, function(x) x$signif))
write.csv(Mantel.16S.Results, "~/Xioben data/Alexa_TRM_analysis/January 2022/Mantel_16S.csv")
```
##16S betadisper tests to test within group variance
```{r}
Betadisp_16S_data <- sample.16S[c(3:12)]
Betadisp_16S_data$PlantID <- as.factor(Betadisp_16S_data$PlantID)
levels(Betadisp_16S_data$PlantID)[levels(Betadisp_16S_data$PlantID)=="F.novae-zelandiae "] <- "F.nz" #formatting issue needed corrected
betadisp_16S <- lapply(Betadisp_16S_data, function(x) vegan::betadisper(unifrac.16S, x, type = "median", bias.adjust = FALSE))
#exporting betadisp distances
betadisp_distances_16S <- data.frame(sapply(betadisp_16S, function(x) x$distances), sapply(betadisp_16S, function(x) x$group))
write.csv(betadisp_distances_16S, "~/Xioben data/Alexa_TRM_analysis/January 2022/betadispDistances_16S.csv")

#permutation tests on betadispersion scores
permu_betadisp_16s <- lapply(betadisp_16S, permutest, pairwise=TRUE)
permu_betadisp_16s.Results <- data.frame(F_value = sapply(permu_betadisp_16s, function(x) x$tab$`F`),
           p.value = sapply(permu_betadisp_16s, function(x) x$tab$`Pr(>F)`))
write.csv(permu_betadisp_16s.Results, "~/Xioben data/Alexa_TRM_analysis/January 2022/Perm_Betadisp_16s.csv")

#pairwise testing on betadispersion
Permu_betadisp_16s.pairwise <- lapply(permu_betadisp_16s, function (x) x$pairwise$permuted <- x$pairwise$permuted[!(x$pairwise$permuted > 0.05)]) #only keeping sig results for output
capture.output(Permu_betadisp_16s.pairwise, file = "~/Xioben data/Alexa_TRM_analysis/January 2022/Permu_Pairwise_Betadisp_16s.csv")
```
##betadispersion summary statistics
```{r}
BD_16S.PlantID <- describe.by(betadisp_unifrac_distances_16S$PlantID, betadisp_unifrac_distances_16S$PlantID.1, mat = TRUE, digits=3)
BD_16S.Genus <- describe.by(betadisp_unifrac_distances_16S$Genus, betadisp_unifrac_distances_16S$Genus.1, mat = TRUE, digits=3)
BD_16S.Family <- describe.by(betadisp_unifrac_distances_16S$Family, betadisp_unifrac_distances_16S$Family.1, mat = TRUE, digits=3)
BD_16S.Order <- describe.by(betadisp_unifrac_distances_16S$Order, betadisp_unifrac_distances_16S$Order.1, mat = TRUE, digits=3)
BD_16S.Class <- describe.by(betadisp_unifrac_distances_16S$Class, betadisp_unifrac_distances_16S$Class.1, mat = TRUE, digits=3)
BD_16S.Provenance <- describe.by(betadisp_unifrac_distances_16S$Provenance, betadisp_unifrac_distances_16S$Provenance.1, mat = TRUE, digits=3)
BD_16S.PMA <- describe.by(betadisp_unifrac_distances_16S$Primary.mycorrhizal.association, betadisp_unifrac_distances_16S$Primary.mycorrhizal.association.1, mat = TRUE, digits=3)
BD_16S.NF <- describe.by(betadisp_unifrac_distances_16S$Nitrogen.fixing, betadisp_unifrac_distances_16S$Nitrogen.fixing.1, mat = TRUE, digits=3)
BD_16S.FG <- describe.by(betadisp_unifrac_distances_16S$Functional.group, betadisp_unifrac_distances_16S$Functional.group.1, mat = TRUE, digits=3)
BD_16S.LS <- describe.by(betadisp_unifrac_distances_16S$Life.span, betadisp_unifrac_distances_16S$Life.span.1, mat = TRUE, digits=3)

#capture in single summary table
Betadispersion_16S_summary <- rbind(BD_16S.PlantID, BD_16S.Genus, BD_16S.Family, BD_16S.Order, BD_16S.Class, BD_16S.Provenance, BD_16S.PMA, BD_16S.NF, BD_16S.FG, BD_16S.LS)
write.csv(Betadispersion_16S_summary, "~/Documents/Alexa_TRM_analysis/January 2022/Betadispersion_summary_16S.csv")
```

#correlating 16S and ITS UniFrac distances with matK sequence distances.\
#merge samples and get mean ASV count
```{r}
physeq_ITS_merged <- merge_samples(physeq.rarefied_ITS, "PlantID", fun = mean)
physeq_ITS_merged
physeq_16S_merged <- merge_samples(physeq.rarefied.16S, "PlantID", fun = mean)
physeq_16S_merged
```
##sample list in 16S and ITS ASV tables need to be in same order as pairwise distance matrix
#no matK data for C.secta or A.caesiigaluca
##need to remove C.secta and A.caesiiglauca from ASV tables and reset order of plant species 
```{r import matk distances}
matK.dist <- read.csv("~/Xioben data/matK/matK_dist.csv")
row.names(matK.dist) = matK.dist$X
matK.dist = matK.dist[,-1]
```
#remove C.secta and A.caesiiglauca from phyloseq object
```{r, message=FALSE}
sample_data(physeq_ITS_merged)$PlantID <- sample_names(physeq_ITS_merged)
sample_data(physeq_16S_merged)$PlantID <- sample_names(physeq_16S_merged)

plants_to_remove <- c("A.caesiiglauca", "C.secta")
physeq_ITS_merged <- subset_samples(physeq_ITS_merged, !(PlantID %in% plants_to_remove))
physeq_16S_merged <- subset_samples(physeq_16S_merged, !(PlantID %in% plants_to_remove))
```
#calculate unifrac distances for new phyloseq objects
```{r, warning=FALSE}
Unifrac.its2 <- phyloseq::distance(physeq_ITS_merged, "wunifrac")
Unifrac.16s2 <- phyloseq::distance(physeq_16S_merged, "wunifrac")
```

# reorder matK table by plant species order in ASV table
```{r}
physeq_ITS_merged3 = as.data.frame(otu_table(physeq_ITS_merged))
physeq_16S_merged3 = as.data.frame(otu_table(physeq_16S_merged))
```
```{r}
matK.dist_ITS <- matK.dist[match(rownames(physeq_ITS_merged3), rownames(matK.dist)), ]
matK.dist_16S <- matK.dist[match(rownames(physeq_16S_merged3), rownames(matK.dist)), ]

matK.dist_ITS <- matK.dist_ITS[,order(colnames(matK.dist_ITS))]
matK.dist_ITS <- as.dist(as.matrix(matK.dist_ITS))
matK.dist_16S <- matK.dist_16S[,order(colnames(matK.dist_16S))]
matK.dist_16S <- as.dist(as.matrix(matK.dist_16S))
```
# matK mantel tests
```{r}
vegan::mantel(Unifrac.its2, matK.dist_ITS, method = "spearman", permutations = 999)
vegan::mantel(Unifrac.16s2, matK.dist_16S, method = "spearman", permutations = 999)
```
#hierarchial clustering of matK distances and unifrac distances
#16S data
```{r}
#16S community data
x16S.cluster <- hclust(Unifrac.16s2, method = "complete")
#MatK data
matK_16S.cluster <- hclust(matK.dist_16S, method = "complete")
```
#plotting 16S crt unifrac vs matK
```{r}
x16S.cluster2 <- ape::as.phylo(x16S.cluster)
matK_16S.cluster2 <- ape::as.phylo(matK_16S.cluster)

tiff("~/Xioben data/Frontiers_Word_Templates/Figures/16S_Unifrac_matK.tiff", units="in", width=10, height=8, res=300)
cophyloplot(x16S.cluster2, matK_16S.cluster2, assoc = NULL, space = 0, length.line = 1, gap = 2, type = "phylogram", rotate = FALSE, col = par("fg"), lwd = par("lwd"), lty = par("lty"),show.tip.label = TRUE, font = 3)
title(xlab="16S rRNA UniFrac distances vs Plant MatK distances")
dev.off()
```
#ITS data
```{r}
#ITS community data
ITS.cluster <- hclust(Unifrac.its2, method = "complete")
#MatK data
matK_ITS.cluster <- hclust(matK.dist_ITS, method = "complete")
```
#plotting ITS crt unifrac vs matK
```{r}
ITS.cluster2 <- ape::as.phylo(ITS.cluster)
matK_ITS.cluster2 <- ape::as.phylo(matK_ITS.cluster)
tiff("~/Xioben data/Frontiers_Word_Templates/Figures/ITS_Unifrac_matK.tiff", units="in", width=10, height=8, res=300)
cophyloplot(ITS.cluster2, matK_ITS.cluster2, assoc = NULL, space = 0, length.line = 1, gap = 2, type = "phylogram", rotate = FALSE, col = par("fg"), lwd = par("lwd"), lty = par("lty"),show.tip.label = TRUE, font = 3)
title(xlab="ITS rRNA UniFrac distances vs Plant MatK distances")
dev.off()
```

##Variance partitioning analysis
##ITS variance partitioning
```{r}
soil.env.ITS <- as.data.frame(sample.ITS2, row.names = rownames(sample.ITS2))
soil.env.ITS <- na.omit(soil.env.ITS)
plant.data.ITS <- data.frame(sample.its[,3:12])
rownames(plant.data.ITS) <- rownames(sample.its)
setdiff(rownames(plant.data.ITS), rownames(soil.env.ITS))
remove_samples2 <- c("kabir_ITS2rcbc368", "kabir_ITS2rcbc343", "kabir_ITS2rcbc354") #removing samples which aren't present in soil chemical data
plant.data.ITS <- plant.data.ITS[!(row.names(plant.data.ITS) %in% remove_samples2), ]

#remove unwanted samples from unifrac matrix
ITS.community <- as.matrix(unifrac.its)
setdiff(rownames(ITS.community), rownames(plant.data.ITS))
ITS.community <- ITS.community[!(row.names(ITS.community) %in% remove_samples2), ] #remove rows
ITS.community <- ITS.community[ , !(colnames(ITS.community) %in% remove_samples2)]
```

## Change the data frame with factors into numeric model matrix. Test effects of plant identity, plant life history, rhizosphere traits, soil chemical conditions, and stohcastic properties (residual variation)
```{r}
mm1_plantID <- model.matrix(~ PlantID, plant.data.ITS)[,-1] #plant identity
mm2_PLHT <- model.matrix(~ Provenance + Life.span + Functional.group, plant.data.ITS)[,-1] #plant life history traits
mm3_PRT <- model.matrix(~ Primary.mycorrhizal.association + Nitrogen.fixing, plant.data.ITS)[,-1] #plant rhizosphere traits
```
# Use RDA to test sigificanance of each indivudal matrix whilst controlling for the other three matrices
```{r}
##testing full model
dbRDA.ALL <- vegan::capscale(ITS.community ~ mm1_plantID + mm2_PLHT + mm3_PRT + as.matrix(soil.env.ITS))
anova(dbRDA.ALL, step=200, perm.max=200) #fit full model

#Plant ID only
rda.result1 <- capscale(ITS.community ~ mm1_plantID + Condition(mm2_PLHT) + Condition(mm3_PRT) + Condition(as.matrix(soil.env.ITS)))
anova(rda.result1, step=200, perm.max=200) 

#soil parameters only
rda.result2 <- capscale(ITS.community ~ as.matrix(soil.env.ITS) + Condition(mm1_plantID) + Condition(mm2_PLHT) + Condition(mm3_PRT))
anova(rda.result2, step=200, perm.max=200)

#Life history parameters only. Non significant
rda.result3 <- capscale(ITS.community ~  mm2_PLHT + Condition(mm1_plantID) + Condition(mm3_PRT) + Condition(as.matrix(soil.env.ITS)))
anova(rda.result3, step=200, perm.max=200)

#Root associations only. Non significant
rda.result4 <- capscale(ITS.community ~  mm3_PRT + Condition(mm1_plantID) + Condition(mm2_PLHT) + Condition(as.matrix(soil.env.ITS)))
anova(rda.result4, step=200, perm.max=200)  
```
##varpart model for ITS data
```{r}
its.varpart <- varpart(ITS.community, mm1_plantID, mm2_PLHT, mm3_PRT, soil.env.ITS)
tiff("~/Xioben data/Frontiers_Word_Templates/Figures/ITS_VarPart.tiff", units="in", width=8, height=5, res=300)
plot(its.varpart, digits = 1, Xnames = c('PI***','PLH', 'PRT', 'SC***'), bg = c('navy', 'purple', 'red', 'yellow'), cex=1.2, id.size=1.2)
dev.off()
```
##16S variance partitioning
```{r}
soil.env.16S <- as.data.frame(sample.16S2, row.names = rownames(sample.16S))
soil.env.16S <- na.omit(soil.env.16S)
plant.data.16S <- data.frame(sample.16S[,3:12])
rownames(plant.data.16S) <- rownames(sample.16S)
setdiff(rownames(plant.data.16S), rownames(soil.env.16S))
remove_samples2 <- c("X614", "X621", "X786") #remvoing samples which aren't present in soil chem data
plant.data.16S <- plant.data.16S[!(row.names(plant.data.16S) %in% remove_samples2), ]

#remove unwanted samples from unifrac matrix
x16S.community <- as.matrix(unifrac.16S)
setdiff(rownames(x16S.community), rownames(plant.data.16S))
x16S.community <- x16S.community[!(row.names(x16S.community) %in% remove_samples2), ] #remove rows
x16S.community <- x16S.community[ , !(colnames(x16S.community) %in% remove_samples2)]
```

##Change the data frame with factors into numeric model matrix. Test effects of plant identity, plant life history, rhizosphere traits, soil chemical conditions, and stohcastic properties (residual variation)
```{r}
mm1_16S_plantID <- model.matrix(~ PlantID, plant.data.16S)[,-1] #plant identity
mm2_16S_PLHT <- model.matrix(~ Provenance + Life.span + Functional.group, plant.data.16S)[,-1] #plant life history traits
mm3_16S_PRT <- model.matrix(~ Primary.mycorrhizal.association + Nitrogen.fixing, plant.data.16S)[,-1] #plant rhizosphere traits
```
# Use RDA to test sigificanance of each indivudal matrix whilst controlling for the other three matrices
```{r}
##testing full model
dbRDA.16S.ALL <- capscale(x16S.community ~ mm1_16S_plantID + mm2_16S_PLHT + mm3_16S_PRT + as.matrix(soil.env.16S))
anova(dbRDA.16S.ALL, step=200, perm.max=200) #fit full model

#Plant ID only. Conditioning for life history, plant root behaviour and soil env properties
rda.16S.result1 <- capscale(x16S.community ~ mm1_16S_plantID + Condition(mm2_16S_PLHT) + Condition(mm3_16S_PRT) + Condition(as.matrix(soil.env.16S)))
anova(rda.16S.result1, step=200, perm.max=200) 

#soil parameters only. Conditioning for plantID, plant root behavior and life history
rda.16S.result2 <- capscale(x16S.community ~ as.matrix(soil.env.16S) + Condition(mm1_16S_plantID) + Condition(mm2_16S_PLHT) + Condition(mm3_16S_PRT))
anova(rda.16S.result2, step=200, perm.max=200)

#Life history parameters only. Non significant. Remove from final varpart model
rda.16S.result3 <- capscale(x16S.community ~  mm2_16S_PLHT + Condition(mm1_16S_plantID) + Condition(mm3_16S_PRT) + Condition(as.matrix(soil.env.16S)))
anova(rda.16S.result3, step=200, perm.max=200)

#Root associations only. Non significant. Remove from final varpart model
rda.16S.result4 <- capscale(x16S.community ~  mm3_16S_PRT + Condition(mm1_16S_plantID) + Condition(mm2_16S_PLHT) + Condition(as.matrix(soil.env.16S)))
anova(rda.16S.result4, step=200, perm.max=200) 
```
##final 16S varpart model 
```{r}
x16s.varpart <- varpart(x16S.community, mm1_16S_plantID, mm2_16S_PLHT, mm3_16S_PRT, soil.env.16S)
tiff("~/Xioben data/Frontiers_Word_Templates/Figures/16S_VarPart.tiff", units="in", width=8, height=5, res=300)
plot(x16s.varpart, digits = 1, Xnames = c('PI***','PLH', 'PRT', 'SC***'), bg = c('navy', 'purple', 'red', 'yellow'), cex=1.2, id.size=1.2)
dev.off()
```

#Forward selection of soil chemical parameters using ordiR2step
##16S
```{r}
rda.16S.0 <- capscale(x16S.community ~ 1, data = soil.env.16S)
rda.16S.all <- capscale(x16S.community ~ pH + Olsen.Phosphorus + Sulphate.Sulphur + Pot..Avail..N + Anaer..Min..N +        Anaer..Min..N.Tot..N + Organic.Matter + Total.Carbon + Total.Nitrogen + C.N.Ratio + Volume.Weight, data = soil.env.16S)
adjR2.all <- RsquareAdj(rda.16S.all)$adj.r.squared
rda.16S.sel <- ordiR2step(rda.16S.0, scope = formula(rda.16S.all), R2scope = adjR2.all, direction= "forward", permutations = 999)
rda.16S.selR2_adj <- rda.16S.sel
rda.16S.selR2_adj$anova$`Pr(>F)` <- p.adjust(rda.16S.selR2_adj$anova$`Pr(>F)`, method = 'bonferroni', n = ncol(soil.env.16S))
x16S_ForwardSel <- rda.16S.selR2_adj$anova
```
##16S capscale using plant species olsen P, pH and sulphate sulphute
```{r}
dbRDA.16S <- capscale(x16S.community ~ Olsen.Phosphorus + pH + Sulphate.Sulphur, data = soil.env.16S)
anova(dbRDA.16S) #just FS soil chem

dbRDA.16S1 <- capscale(x16S.community ~ Olsen.Phosphorus + pH + Sulphate.Sulphur, mm1_16S_plantID, data = soil.env.16S)
anova(dbRDA.16S1) #FS soil chem + plant ID
```

##ITS.
```{r}
rda.ITS.0 <- capscale(ITS.community ~ 1, data = soil.env.ITS)
rda.ITS.all <- capscale(ITS.community ~ pH + Olsen.Phosphorus + Sulphate.Sulphur + Pot..Avail..N + Anaer..Min..N +        Anaer..Min..N.Tot..N + Organic.Matter + Total.Carbon + Total.Nitrogen + C.N.Ratio + Volume.Weight, data = soil.env.ITS)
adjR2.all <- RsquareAdj(rda.ITS.all)$adj.r.squared
rda.ITS.sel <- ordiR2step(rda.ITS.0, scope = formula(rda.ITS.all), R2scope = adjR2.all, direction= "forward", permutations = 999)
rda.ITS.selR2_adj <- rda.ITS.sel
rda.ITS.selR2_adj$anova$`Pr(>F)` <- p.adjust(rda.ITS.selR2_adj$anova$`Pr(>F)`, method = 'bonferroni', n = ncol(soil.env.ITS))
ITS_ForwardSel <- rda.ITS.selR2_adj$anova
```
##ITS capscale using plant species olsen P, pH and sulphate sulphute
```{r}
dbRDA.ITS <- vegan::capscale(ITS.community ~ Olsen.Phosphorus + Anaer..Min..N.Tot..N + Volume.Weight, data = soil.env.ITS)
anova(dbRDA.ITS)

dbRDA.ITS1 <- vegan::capscale(ITS.community ~ Olsen.Phosphorus + Anaer..Min..N.Tot..N + Volume.Weight + mm1_plantID, data = soil.env.ITS)
anova(dbRDA.ITS1)
```

##boxplots to visualise soil chem parameters
#filter chem data to only retain variables of interest
```{r}
sampleData <- read.csv("~/Documents/Alexa_TRM_analysis/16S data/DADA2 outputs/16S_samples_post_filtering.csv")
retain_data <- c("PlantID", "Olsen.Phosphorus", "Anaer..Min..N.Tot..N", "Volume.Weight", "pH", "Sulphate.Sulphur")
sampleData <- sampleData[, which((names(sampleData) %in% retain_data)==TRUE)]
sampleData <- na.omit(sampleData) #remove NA values
#remove no plant data
sampleData <- subset(sampleData, PlantID != "NPD")
sampleData <- sampleData[order(sampleData$PlantID), ] #sort alphabetically
sampleData$PlantID <- as.factor(sampleData$PlantID)
```
#boxplots
```{r}
#olsen P
Olsen_P <- ggplot(sampleData, aes(x=Olsen.Phosphorus, y=PlantID))+ 
  geom_boxplot(outlier.shape = NA)+
  theme_bw()+
  ylab("Plant species")+
  xlab("Olsen P (mg/L)")+
  scale_y_discrete(limits=rev) +
  theme(axis.title = element_text(face="bold"))+
  stat_summary(fun.y=mean, geom="point")
tiff("~/Documents/Alexa_TRM_analysis/January 2022/Figures/Olsen_P.tiff", units="in", width=5, height=6, res=300)
Olsen_P

#sulphate sulphur
Sulphate_S <- ggplot(sampleData, aes(x=Sulphate.Sulphur, y=PlantID))+ 
  geom_boxplot(outlier.shape = NA)+
  theme_bw()+
  ylab("Plant species")+
  xlab("Sulphate Sulphur (mg/kg)")+
  scale_y_discrete(limits=rev) +
  theme(axis.title = element_text(face="bold"))+
  stat_summary(fun.y=mean, geom="point")
tiff("~/Documents/Alexa_TRM_analysis/January 2022/Figures/Sulphate_S.tiff", units="in", width=5, height=6, res=300)
Sulphate_S
#pH
pH <- ggplot(sampleData, aes(x=pH, y=PlantID))+ 
  geom_boxplot(outlier.shape = NA)+
  theme_bw()+
  ylab("Plant species")+
  xlab("pH")+
  scale_y_discrete(limits=rev) +
  theme(axis.title = element_text(face="bold"))+
  stat_summary(fun.y=mean, geom="point")
tiff("~/Documents/Alexa_TRM_analysis/January 2022/Figures/pH.tiff", units="in", width=5, height=6, res=300)
pH
#volume weight
Vol_Wt <- ggplot(sampleData, aes(x=Volume.Weight, y=PlantID))+ 
  geom_boxplot(outlier.shape = NA)+
  theme_bw()+
  ylab("Plant species")+
  xlab("Volume weight (g/ml)")+
  scale_y_discrete(limits=rev) +
  theme(axis.title = element_text(face="bold"))+
  stat_summary(fun.y=mean, geom="point")
tiff("~/Documents/Alexa_TRM_analysis/January 2022/Figures/Vol_Weight.tiff", units="in", width=5, height=6, res=300)
Vol_Wtpacka
#AMN:TN
AMN_TN <- ggplot(sampleData, aes(x=Anaer..Min..N.Tot..N, y=PlantID))+ 
  geom_boxplot(outlier.shape = NA)+
  theme_bw()+
  ylab("Plant species")+
  xlab("AMN:TN")+
  scale_y_discrete(limits=rev) +
  theme(axis.title = element_text(face="bold"))+
  stat_summary(fun.y=mean, geom="point")
tiff("~/Documents/Alexa_TRM_analysis/January 2022/Figures/AMN_TN.tiff", units="in", width=5, height=6, res=300)
AMN_TN
```
#PIME: Prevalance Interval for Microbiome Evalution. PIME removes the within group variation found in metataxonomic surveys (16S rRNA datasets) by capturing only biological differences at high samples prevalence levels

#provides a prevalence filtered dataset which can then be passed onto other forms of differential abundance and compositional analysis 

#https://bocasbiome.github.io/wf7.html
#https://github.com/microEcology/pime
#see paper: https://doi.org/10.1111/1755-0998.13116

```{r}
#remotes::install_github("microEcology/pime")
library(pime)
```
#Remove phytree from phyloseq object or else analysis won't run
```{r create 16S phyloseq object}
physeq.rarefied_ITS@phy_tree <- NULL
physeq.rarefied.16S@phy_tree <- NULL
```
#Prediction using random forests on full dataset. Results in Out of Bag error rate. Baseline noise detection. 
```{r}
pime.oob.error(physeq.rarefied_ITS, "PlantID") ##OOB error rate 0.806
pime.oob.error(physeq.rarefied.16S, "PlantID") ##OOB error rate 0.84
```
#split dataset by variable.
```{r}
per_variable_ITS = pime.split.by.variable(physeq.rarefied_ITS, "PlantID")
per_variable_16S = pime.split.by.variable(physeq.rarefied.16S, "PlantID")
```
#calculate highest possible prevalance intervals
```{r}
prevalences_ITS = pime.prevalence(per_variable_ITS)
head(prevalences_ITS)
prevalences_16S = pime.prevalence(per_variable_16S)
head(prevalences_16S)
```
#calculate best prevalence interval for the datset
#uses randomForest to build random forests trees for samples classification and variable importance computation
#The best prevalence interval value provides the clearest separation of communities while including a majority of the taxa
#first interval where OOB error rate is zero
#returns Mean Decrease Accuracy (MDA), Mean Decrease Impurity (MDI), overall and by sample group, and taxonomy for each ASV. PIME keeps the top 30 variables with highest MDA each prevalence level
```{r}
#its
set.seed(42)
best.prev.ITS = pime.best.prevalence(prevalences_ITS, "PlantID") #0% OOB from prevalence 80% with 186 ASVs
best.prev.ITS$`OOB error`

#16s
set.seed(42)
best.prev.16S = pime.best.prevalence(prevalences_16S, "PlantID") #0% OOB from prevalence 85% with 633 ASVs
best.prev.16S$`OOB error`
```
#return results from random forest classification. table with OTU/ASV importance of the chosen prevalence interval. Pime keeps only the top 30 OTUs/ASVs, with highest MDA.
```{r}
imp80_ITS = best.prev.ITS$`Importance`$`Prevalence 80`
write.csv(imp80_ITS, file = "~/Documents/Alexa_TRM_analysis/January 2022/ITS_output_PIME_75p.csv")
imp85_16S = best.prev.16S$`Importance`$`Prevalence 85`
write.csv(imp85_16S, file = "~/Documents/Alexa_TRM_analysis/January 2022/16S_output_PIME_85p.csv")
```
#using prevalence 80 and 85
#obtain phyloseq object at desired cutoff
```{r}
prevalence.80_ITS = prevalences_ITS$`80`
prevalence.80_ITS
saveRDS(prevalence.80_ITS, "~/Documents/Alexa_TRM_analysis/January 2022/ITS_Pime_Prevalence_80.rds")

prevalence.85_16S = prevalences_16S$`85`
prevalence.85_16S
saveRDS(prevalence.85_16S, "~/Documents/Alexa_TRM_analysis/January 2022/16S_Pime_Prevalence_85.rds")
```
#estimating prediction error
```{r}
randomized_ITS = pime.error.prediction(physeq.rarefied_ITS, "PlantID", bootstrap = 100, parallel = TRUE, max.prev = 95)
randomized_ITS$Plot
write.csv(randomized_ITS$`Results table`, "~/Documents/Alexa_TRM_analysis/January 2022/prediction-error-ITS.csv")

#estimate OOB error with each prevalence interval filtering
replicated.oob.error_ITS = pime.oob.replicate(prevalences_ITS, "PlantID", bootstrap = 100, parallel = TRUE)
write.csv(replicated.oob.error_ITS$`Results table`, "~/Documents/Alexa_TRM_analysis/January 2022/OOB-prediction-error-ITS.csv")

randomized_16S = pime.error.prediction(physeq.rarefied.16S, "PlantID", bootstrap = 100, parallel = TRUE, max.prev = 95)
randomized_16S$Plot
write.csv(randomized_16S$`Results table`, "~/Documents/Alexa_TRM_analysis/January 2022/prediction-error-16S.csv")

#estimate OOB error with each prevalence interval filtering
replicated.oob.error_16S = pime.oob.replicate(prevalences_16S, "PlantID", bootstrap = 100, parallel = TRUE)
```

##idenitfy ITS ASVs which significantly vary across plant species
```{r}
pime_metaSeq_ITS <- phyloseq_to_metagenomeSeq(prevalence.80_ITS)
pime_metaSeq_ITS.n = cumNorm(pime_metaSeq_ITS, p = cumNormStat(pime_metaSeq_ITS)) #cumulative sum scaling normalization

##Computes a log-normal linear model and permutation based p-values
plantID = pData(pime_metaSeq_ITS.n)$PlantID
mod = model.matrix(~ 0 + plantID)
fit_ITS = fitLogNormal(obj = pime_metaSeq_ITS.n,mod=mod,B=999) #fit model
adjustedPvalues = p.adjust(fit_ITS$p, method = "holm") #adj p values for multiple comparisons

##extract results
Pime_lmFit_t <- as.data.frame(fit_ITS$t) #model t values
Pime_lmFit_p.adj <- as.data.frame(adjustedPvalues) #adjusted p values
Pime_lmFit_FC <- as.data.frame(fit_ITS$fit$coefficients)
Pime_lmFit_FC <- cbind(Pime_lmFit_FC, Pime_lmFit_p.adj)
write.csv(Pime_lmFit_t, "~/Documents/Alexa_TRM_analysis/January 2022/lmFit_t_ITS.csv")
write.csv(Pime_lmFit_p.adj, "~/Documents/Alexa_TRM_analysis/January 2022/lmFit_padj_ITS.csv")
write.csv(Pime_lmFit_FC, "~/Documents/Alexa_TRM_analysis/January 2022/lmFit_ITS.csv")
#get taxa names for reference
#get taxa names for reference
lmFit_ITS_taxa <- as.data.frame(tax_table(prevalence.80_ITS))
lmFit_ITS_taxa['ASV_ID'] <- rownames(lmFit_ITS_taxa)
#match order of ASVs
ordered_ITS_taxa <- rownames(Pime_lmFit_t)
lmFit_ITS_taxa2 <- lmFit_ITS_taxa[match(ordered_ITS_taxa, lmFit_ITS_taxa$ASV_ID),]
write.csv(lmFit_ITS_taxa2, "~/Documents/Alexa_TRM_analysis/January 2022/lmFit_taxa_ITS.csv")
```
#filter ITS ASVs from phyloseq object which do not sig vary by plant ID
```{r}
Pime_lmFit_p.adj["ASV"] <- rownames(Pime_lmFit_p.adj)
Pime_lmFit_p.adj <- Pime_lmFit_p.adj[Pime_lmFit_p.adj$adjustedPvalues <= "0.05", ] #select significant p-values
keep_its_asvs <- Pime_lmFit_p.adj$ASV
prevalence.80_ITS3 <- prune_taxa(keep_its_asvs, prevalence.80_ITS)
```

##idenitfy 16S ASVs which significantly vary across plant species
```{r}
pime_metaSeq_16S <- phyloseq_to_metagenomeSeq(prevalence.85_16S)
pime_metaSeq_16S.n = cumNorm(pime_metaSeq_16S, p = cumNormStat(pime_metaSeq_16S)) #cumulative sum scaling normalization

##Computes a log-normal linear model and permutation based p-values
plantID2 = pData(pime_metaSeq_16S.n)$PlantID
mod2 = model.matrix(~ 0 + plantID2)
fit_16S = fitLogNormal(obj = pime_metaSeq_16S.n,mod=mod2,B=999) #fit model
adjustedPvalues2 = p.adjust(fit_16S$p, method = "holm") #adj p values for multiple comparisons

##extract results
Pime_lmFit_t2 <- as.data.frame(fit_16S$t) #model t values
Pime_lmFit_p.adj2 <- as.data.frame(adjustedPvalues2) #adjusted p values
Pime_lmFit_FC2 <- as.data.frame(fit_16S$fit$coefficients)
Pime_lmFit_FC2 <- cbind(Pime_lmFit_FC2, Pime_lmFit_p.adj2)
write.csv(Pime_lmFit_t2, "~/Documents/Alexa_TRM_analysis/January 2022/lmFit_t_16S.csv")
write.csv(Pime_lmFit_p.adj2, "~/Documents/Alexa_TRM_analysis/January 2022/lmFit_padj_16S.csv")
write.csv(Pime_lmFit_FC2, "~/Documents/Alexa_TRM_analysis/January 2022/lmFit_16S.csv")
#get taxa names for reference
lmFit_16S_taxa <- as.data.frame(tax_table(prevalence.85_16S))
lmFit_16S_taxa['ASV_ID'] <- rownames(lmFit_16S_taxa)
#match order of ASVs
ordered_16S_taxa <- rownames(Pime_lmFit_t2)
lmFit_16S_taxa2 <- lmFit_16S_taxa[match(ordered_16S_taxa, lmFit_16S_taxa$ASV_ID),]
write.csv(lmFit_16S_taxa2, "~/Documents/Alexa_TRM_analysis/January 2022/lmFit_taxa_16S.csv")
```

#filter 16S ASVs from phyloseq object which do not sig vary by plant ID
```{r}
Pime_lmFit_p.adj2["ASV"] <- rownames(Pime_lmFit_p.adj2)
Pime_lmFit_p.adj2 <- Pime_lmFit_p.adj2[Pime_lmFit_p.adj2$adjustedPvalues2 <= "0.05", ] #select significant p-values
keep_16s_asvs <- Pime_lmFit_p.adj2$ASV
prevalence.85_16S3 <- prune_taxa(keep_16s_asvs, prevalence.85_16S)
```
#export list prevalence filtered taxa which were significantly different (p< 0.05) between plant species
```{r}
its_asvs_final <- as.data.frame(otu_table(prevalence.80_ITS3))
its_taxa_final <- as.data.frame(tax_table(prevalence.80_ITS3))
its_pime_final <- cbind(its_asvs_final, its_taxa_final)
write.csv(its_pime_final, "~/Documents/Alexa_TRM_analysis/January 2022/its_pime_final.csv")

x16s_asvs_final <- as.data.frame(otu_table(prevalence.85_16S3))
x16s_taxa_final <- as.data.frame(tax_table(prevalence.85_16S3))
x16s_pime_final <- cbind(x16s_asvs_final, x16s_taxa_final)
write.csv(x16s_pime_final, "~/Documents/Alexa_TRM_analysis/January 2022/x16s_pime_final.csv")

#non significant taxa which passed prevalence filtering
its_asvs_final2 <- as.data.frame(otu_table(prevalence.80_ITS))
its_taxa_final2 <- as.data.frame(tax_table(prevalence.80_ITS))
its_pime_final2 <- cbind(its_asvs_final2, its_taxa_final2)
write.csv(its_pime_final2, "~/Documents/Alexa_TRM_analysis/January 2022/its_pime_final_all.csv")

x16s_asvs_final2 <- as.data.frame(otu_table(prevalence.85_16S))
x16s_taxa_final2 <- as.data.frame(tax_table(prevalence.85_16S))
x16s_pime_final2 <- cbind(x16s_asvs_final2, x16s_taxa_final2)
write.csv(x16s_pime_final2, "~/Documents/Alexa_TRM_analysis/January 2022/x16s_pime_final_all.csv")
```

##plotting taxonomic differences 
```{r}
#install.packages("pheatmap")
library(pheatmap)
```
##ITS
```{r}
#remove non sig taxa 
Pime_lmFit_FC <- dplyr::filter(Pime_lmFit_FC, adjustedPvalues < 0.05)
colnames(Pime_lmFit_FC) <- c("A.caesiiglauca" , "A.capillaris" , "A.dealbata" , "A.glutinosa", "A.inermis", "A.lessoniana", "A.millefolium", "B.greyi", "C.conspicua", "C.robusta", "C.secta", "C.vulgare", "D.glomerata", "E.vulgare", "F.novae-zelandiae ", "H.lanatus", "H.odora", "H.perforatum", "L.aboreus", "L.perenne", "M.astonii", "M.complexa", "M.sativa", "O.leptophyllus", "O.virgata", "P.cita", "P.colensoi", "P.contorta", "P.cookianum", "P.radiata", "P.totara", "R.acetosella", "R.obtusifolius", "S.microphylla", "T.pratense", "T.repens", "U.europaeus", "")
Pime_lmFit_FC <- Pime_lmFit_FC[,-38:-40]
Pime_lmFit_FC.t = t(Pime_lmFit_FC) #transpose for heatmap

#heatmap
tiff("~/Documents/Alexa_TRM_analysis/ITS_heatmap.tiff", units="in", width=10, height=8, res=300)
ITS_heatmap <- pheatmap(Pime_lmFit_FC.t, cex=0.9) #plant species and asvs clustered via hclust
dev.off()
```

##plotting 16S taxonomic heatmap
```{r}
#remove non sig taxa 
Pime_lmFit_FC2 <- dplyr::filter(Pime_lmFit_FC2, adjustedPvalues2 < 0.05)
colnames(Pime_lmFit_FC2) <- c("A.caesiiglauca" , "A.capillaris" , "A.dealbata" , "A.glutinosa", "A.inermis", "A.lessoniana", "A.millefolium", "B.greyi", "C.conspicua", "C.robusta", "C.secta", "C.vulgare", "D.glomerata", "E.vulgare", "F.novae-zelandiae ", "H.lanatus", "H.odora", "H.perforatum", "L.aboreus", "L.perenne", "M.astonii", "M.complexa", "M.sativa", "O.leptophyllus", "O.virgata", "P.cita", "P.colensoi", "P.contorta", "P.cookianum", "P.radiata", "P.totara", "R.acetosella", "R.obtusifolius", "S.microphylla", "T.pratense", "T.repens", "U.europaeus", "")
Pime_lmFit_FC2.t = t(Pime_lmFit_FC2) #transpose for heatmap

#heatmap
tiff("~/Documents/Alexa_TRM_analysis/January 2022/16S_heatmap.tiff", units="in", width=14, height=8, res=300)
x16S_heatmap <- pheatmap(Pime_lmFit_FC2.t, cex=0.9) #plant species and asvs clustered via hclust
dev.off()
```

###plotting heatmaps correlating plants on 16S and ITS asv log fold change
##make heatmap/perform analysis for each metadata factor.
```{r}
Pime_lmFit_FoldChange <- as.data.frame(fit_ITS$fit$coefficients)
Pime_lmFit_FoldChange2 <- as.data.frame(fit_16S$fit$coefficients)
colnames(Pime_lmFit_FoldChange) <- c("A.caesiiglauca" , "A.capillaris" , "A.dealbata" , "A.glutinosa", "A.inermis", "A.lessoniana", "A.millefolium", "B.greyi", "C.conspicua", "C.robusta", "C.secta", "C.vulgare", "D.glomerata", "E.vulgare", "F.novae-zelandiae ", "H.lanatus", "H.odora", "H.perforatum", "L.aboreus", "L.perenne", "M.astonii", "M.complexa", "M.sativa", "O.leptophyllus", "O.virgata", "P.cita", "P.colensoi", "P.contorta", "P.cookianum", "P.radiata", "P.totara", "R.acetosella", "R.obtusifolius", "S.microphylla", "T.pratense", "T.repens", "U.europaeus")
colnames(Pime_lmFit_FoldChange2) <- c("A.caesiiglauca" , "A.capillaris" , "A.dealbata" , "A.glutinosa", "A.inermis", "A.lessoniana", "A.millefolium", "B.greyi", "C.conspicua", "C.robusta", "C.secta", "C.vulgare", "D.glomerata", "E.vulgare", "F.novae-zelandiae ", "H.lanatus", "H.odora", "H.perforatum", "L.aboreus", "L.perenne", "M.astonii", "M.complexa", "M.sativa", "O.leptophyllus", "O.virgata", "P.cita", "P.colensoi", "P.contorta", "P.cookianum", "P.radiata", "P.totara", "R.acetosella", "R.obtusifolius", "S.microphylla", "T.pratense", "T.repens", "U.europaeus")
```
#correlation plot between plant species 
#format dataframes for plotting
```{r}
library(reshape2)
plantID_cormat <- cor(Pime_lmFit_FoldChange)
head(plantID_cormat)

  # Get upper triangle of the correlation matrix
  get_upper_tri <- function(cormat){
    cormat[lower.tri(cormat)]<- NA
    return(cormat)
  }
#formatting fungi 
upper_tri <- get_upper_tri(plantID_cormat)
plantID_cormat.m <- melt(upper_tri, na.rm = TRUE)
head(plantID_cormat.m)

#formatting bacteria
plantID_cormat2 <- cor(Pime_lmFit_FoldChange2)
upper_tri2 <- get_upper_tri(plantID_cormat2)
plantID_cormat.m2 <- melt(upper_tri2, na.rm = TRUE)
head(plantID_cormat.m2)
```
```{r}
##fungi corrplot
PlantID_corplot <- ggplot(data = plantID_cormat.m, aes(x=Var1, y=Var2, fill=value)) + 
  geom_tile(color = "white")+
  xlab("Plant species")+
  ylab("Plant species")+
 scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
   midpoint = 0, limit = c(-1,1), space = "Lab", 
   name="Pearson\nCorrelation") +
  theme_minimal()+ 
 theme(axis.text.x = element_text(angle = 90, vjust = 1, 
    size = 8, hjust = 1), axis.text.y = element_text(angle = 0, vjust = 1, 
    size = 8, hjust = 1))+
 coord_fixed()
tiff("~/Documents/Alexa_TRM_analysis/January 2022/Figures/Corrplot_Species_ITS.tiff", units="in", width=6, height=6, res=300)
PlantID_corplot
```
```{r}
##bacteria corrplot
PlantID_corplot_16S <- ggplot(data = plantID_cormat.m2, aes(x=Var1, y=Var2, fill=value)) + 
  geom_tile(color = "white")+
  xlab("Plant species")+
  ylab("Plant species")+
 scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
   midpoint = 0, limit = c(-1,1), space = "Lab", 
   name="Pearson\nCorrelation") +
  theme_minimal()+ 
 theme(axis.text.x = element_text(angle = 90, vjust = 1, 
    size = 8, hjust = 1), axis.text.y = element_text(angle = 0, vjust = 1, 
    size = 8, hjust = 1))+
 coord_fixed()
tiff("~/Documents/Alexa_TRM_analysis/January 2022/Figures/Corrplot_Species_16S.tiff", units="in", width=6, height=6, res=300)
PlantID_corplot_16S
```
##extracting p-values for correlation matrices
```{r}
flat_cor_mat <- function(cor_r, cor_p){
  #This function provides a simple formatting of a correlation matrix
  #into a table with 4 columns containing :
    # Column 1 : row names (variable 1 for the correlation test)
    # Column 2 : column names (variable 2 for the correlation test)
    # Column 3 : the correlation coefficients
    # Column 4 : the p-values of the correlations
  library(tidyr)
  library(tibble)
  cor_r <- rownames_to_column(as.data.frame(cor_r), var = "row")
  cor_r <- gather(cor_r, column, cor, -1)
  cor_p <- rownames_to_column(as.data.frame(cor_p), var = "row")
  cor_p <- gather(cor_p, column, p, -1)
  cor_p_matrix <- left_join(cor_r, cor_p, by = c("row", "column"))
  cor_p_matrix
}
```
##extracting correlation data
```{r}
##fungi
SpeciesCor <- Hmisc::rcorr(as.matrix(Pime_lmFit_FoldChange))
Species_cor_matrix <- flat_cor_mat(SpeciesCor$r, SpeciesCor$P)
write.csv(Species_cor_matrix, "~/Documents/Alexa_TRM_analysis/January 2022/Species_corMatrix_ITS.csv")

##bacteria
SpeciesCor2 <- Hmisc::rcorr(as.matrix(Pime_lmFit_FoldChange2))
Species_cor_matrix2 <- flat_cor_mat(SpeciesCor2$r, SpeciesCor2$P)
write.csv(Species_cor_matrix2, "~/Documents/Alexa_TRM_analysis/January 2022/Species_corMatrix_16S.csv")
```



Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
